# <int:n> primes_slow <int:prime_0> ... <int:primeM>
#
# primes_slow(n):
# 
# return all the primes upto n, in a extremely ineficient manner
@primes_slow
{
    mark swap
    dup 2 gt
    {
        1 aset
        2 swap 3 2 3 -1 roll 
        # for 2 .. (n)
        {
            # <M> Po .... Pn i
            @save 1 def

            aget -1 1
            {
                # <M> a b c Po .... Pn i j
                index 
                # <M> .... Pn i Pj
                3 times
                mul
                # <M> .... Pn i Pj Pj2
                2 index 
                # M ... Pn i Pj Pj2 i
                lte
                {
                    # M ... Pn i Pj
                    1 index 3 1 roll
                    # M ...Pn i i Pj
                    mod
                    # M ... Pn i m
                    EqZ
                    {
                        @save 0 def
                        break
                    }
                    if
                }
                {
                    # M ... Pn i Pj
                    pop
                    break
                }
                ifelse
            }
            for

            $save eqz
            {
                pop
            }
            {
                aget inc aset
            }
            ifelse
        }
        for
    }
    {
        dup
        2 neq
        {
            pop
        }
        if
    }
    ifelse
}
def

20000 $primes_slow
